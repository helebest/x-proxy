import { describe, it, expect, beforeEach } from 'vitest';
import { PACGenerator } from '@/pac/PACGenerator';
import { Rule, RuleType, RulePriority } from '@/rules/types';
import { ProxyProfile, ProxyType } from '@/types/proxy';
import { PACGenerationOptions } from '@/pac/types';

describe('PACGenerator', () => {
  let generator: PACGenerator;
  let testProfiles: ProxyProfile[];
  let testRules: Rule[];

  beforeEach(() => {
    // Setup test profiles
    testProfiles = [
      {
        id: 'profile-1',
        name: 'US Proxy',
        config: {
          type: ProxyType.HTTP,
          host: 'us-proxy.example.com',
          port: 8080
        },
        isActive: false,
        createdAt: new Date(),
        updatedAt: new Date()
      },
      {
        id: 'profile-2',
        name: 'EU Proxy',
        config: {
          type: ProxyType.SOCKS5,
          host: 'eu-proxy.example.com',
          port: 1080
        },
        isActive: false,
        createdAt: new Date(),
        updatedAt: new Date()
      }
    ];

    // Setup test rules
    testRules = [
      {
        id: 'rule-1',
        name: 'US Sites',
        type: RuleType.DOMAIN,
        pattern: '*.us.example.com',
        profileId: 'profile-1',
        priority: RulePriority.HIGH,
        enabled: true,
        createdAt: new Date(),
        updatedAt: new Date()
      },
      {
        id: 'rule-2',
        name: 'EU Sites',
        type: RuleType.DOMAIN,
        pattern: '*.eu.example.com',
        profileId: 'profile-2',
        priority: RulePriority.MEDIUM,
        enabled: true,
        createdAt: new Date(),
        updatedAt: new Date()
      },
      {
        id: 'rule-3',
        name: 'Block Ads',
        type: RuleType.WILDCARD,
        pattern: '*doubleclick.net*',
        profileId: null, // Block (no proxy)
        priority: RulePriority.CRITICAL,
        enabled: true,
        createdAt: new Date(),
        updatedAt: new Date()
      }
    ];

    generator = new PACGenerator(testProfiles);
  });

  describe('generate', () => {
    it('should generate a basic PAC script', () => {
      const script = generator.generate(testRules);
      
      expect(script).toContain('function FindProxyForURL(url, host)');
      expect(script).toContain('return');
    });

    it('should include header comment when not minified', () => {
      const options: PACGenerationOptions = {
        minify: false,
        headerComment: 'Test PAC Script'
      };

      const script = generator.generate(testRules, options);
      
      expect(script).toContain('PAC Script generated by X-Proxy');
      expect(script).toContain('Test PAC Script');
    });

    it('should not include header when minified', () => {
      const options: PACGenerationOptions = {
        minify: true
      };

      const script = generator.generate(testRules, options);
      
      expect(script).not.toContain('PAC Script generated by X-Proxy');
    });

    it('should include helper functions', () => {
      const script = generator.generate(testRules);
      
      expect(script).toContain('function isLocalNetwork(host)');
      expect(script).toContain('function isInDomainList(host, domains)');
      expect(script).toContain('function matchesPattern(str, pattern)');
    });

    it('should include debug functions when requested', () => {
      const options: PACGenerationOptions = {
        includeDebug: true
      };

      const script = generator.generate(testRules, options);
      
      expect(script).toContain('var debugMode = true');
      expect(script).toContain('function debug(msg)');
    });

    it('should bypass proxy for local addresses', () => {
      const script = generator.generate(testRules);
      
      expect(script).toContain('if (isLocalNetwork(host))');
      expect(script).toContain('return "DIRECT"');
    });

    it('should sort rules by priority', () => {
      const script = generator.generate(testRules);
      
      // Critical priority rule should appear first
      const blockAdsIndex = script.indexOf('Block Ads');
      const usSitesIndex = script.indexOf('US Sites');
      const euSitesIndex = script.indexOf('EU Sites');
      
      expect(blockAdsIndex).toBeLessThan(usSitesIndex);
      expect(usSitesIndex).toBeLessThan(euSitesIndex);
    });

    it('should use default proxy when specified', () => {
      const options: PACGenerationOptions = {
        defaultProxy: 'PROXY default.proxy.com:3128'
      };

      const script = generator.generate(testRules, options);
      
      expect(script).toContain('return "PROXY default.proxy.com:3128"');
    });

    it('should handle empty rules array', () => {
      const script = generator.generate([]);
      
      expect(script).toContain('function FindProxyForURL(url, host)');
      expect(script).toContain('return "DIRECT"');
    });

    it('should handle disabled rules', () => {
      const rules = [
        {
          ...testRules[0],
          enabled: false
        }
      ];

      const script = generator.generate(rules);
      
      expect(script).not.toContain('US Sites');
    });
  });

  describe('convertRulesToMappings', () => {
    it('should convert domain rules correctly', () => {
      const rule: Rule = {
        id: 'test',
        name: 'Test Domain',
        type: RuleType.DOMAIN,
        pattern: 'example.com',
        profileId: 'profile-1',
        priority: RulePriority.MEDIUM,
        enabled: true,
        createdAt: new Date(),
        updatedAt: new Date()
      };

      const script = generator.generate([rule]);
      expect(script).toContain('dnsDomainIs(host, "example.com")');
    });

    it('should convert wildcard rules correctly', () => {
      const rule: Rule = {
        id: 'test',
        name: 'Test Wildcard',
        type: RuleType.WILDCARD,
        pattern: '*.example.com',
        profileId: 'profile-1',
        priority: RulePriority.MEDIUM,
        enabled: true,
        createdAt: new Date(),
        updatedAt: new Date()
      };

      const script = generator.generate([rule]);
      expect(script).toContain('shExpMatch');
    });

    it('should convert regex rules correctly', () => {
      const rule: Rule = {
        id: 'test',
        name: 'Test Regex',
        type: RuleType.REGEX,
        pattern: '^https?://[^/]*\\.example\\.com',
        profileId: 'profile-1',
        priority: RulePriority.MEDIUM,
        enabled: true,
        createdAt: new Date(),
        updatedAt: new Date()
      };

      const script = generator.generate([rule]);
      expect(script).toContain('new RegExp');
    });

    it('should convert IP range rules correctly', () => {
      const rule: Rule = {
        id: 'test',
        name: 'Test IP Range',
        type: RuleType.IP_RANGE,
        pattern: '192.168.1.0/24',
        profileId: 'profile-1',
        priority: RulePriority.MEDIUM,
        enabled: true,
        createdAt: new Date(),
        updatedAt: new Date()
      };

      const script = generator.generate([rule]);
      expect(script).toContain('isInNet');
    });
  });

  describe('generateProxyString', () => {
    it('should generate correct proxy string for HTTP proxy', () => {
      const profile: ProxyProfile = {
        id: 'test',
        name: 'HTTP Proxy',
        config: {
          type: ProxyType.HTTP,
          host: 'proxy.example.com',
          port: 8080
        },
        isActive: false,
        createdAt: new Date(),
        updatedAt: new Date()
      };

      generator.updateProfiles([profile]);
      const rule: Rule = {
        id: 'test',
        name: 'Test',
        type: RuleType.DOMAIN,
        pattern: 'example.com',
        profileId: 'test',
        priority: RulePriority.MEDIUM,
        enabled: true,
        createdAt: new Date(),
        updatedAt: new Date()
      };

      const script = generator.generate([rule]);
      expect(script).toContain('PROXY proxy.example.com:8080');
    });

    it('should generate correct proxy string for SOCKS5 proxy', () => {
      const profile: ProxyProfile = {
        id: 'test',
        name: 'SOCKS5 Proxy',
        config: {
          type: ProxyType.SOCKS5,
          host: 'socks.example.com',
          port: 1080
        },
        isActive: false,
        createdAt: new Date(),
        updatedAt: new Date()
      };

      generator.updateProfiles([profile]);
      const rule: Rule = {
        id: 'test',
        name: 'Test',
        type: RuleType.DOMAIN,
        pattern: 'example.com',
        profileId: 'test',
        priority: RulePriority.MEDIUM,
        enabled: true,
        createdAt: new Date(),
        updatedAt: new Date()
      };

      const script = generator.generate([rule]);
      expect(script).toContain('SOCKS5 socks.example.com:1080');
    });

    it('should return DIRECT for rules without profileId', () => {
      const rule: Rule = {
        id: 'test',
        name: 'Direct',
        type: RuleType.DOMAIN,
        pattern: 'example.com',
        profileId: null,
        priority: RulePriority.MEDIUM,
        enabled: true,
        createdAt: new Date(),
        updatedAt: new Date()
      };

      const script = generator.generate([rule]);
      expect(script).toContain('return "DIRECT"');
    });
  });

  describe('optimization', () => {
    it('should group rules by proxy result', () => {
      const rules: Rule[] = [
        {
          id: 'rule-1',
          name: 'Site 1',
          type: RuleType.DOMAIN,
          pattern: 'site1.com',
          profileId: 'profile-1',
          priority: RulePriority.MEDIUM,
          enabled: true,
          createdAt: new Date(),
          updatedAt: new Date()
        },
        {
          id: 'rule-2',
          name: 'Site 2',
          type: RuleType.DOMAIN,
          pattern: 'site2.com',
          profileId: 'profile-1',
          priority: RulePriority.MEDIUM,
          enabled: true,
          createdAt: new Date(),
          updatedAt: new Date()
        }
      ];

      const script = generator.generate(rules);
      
      // Should group rules with same proxy together
      expect(script).toMatch(/Rules: Site 1, Site 2/);
    });

    it('should apply optimization when requested', () => {
      const options: PACGenerationOptions = {
        optimizationLevel: 2
      };

      const script = generator.generate(testRules, options);
      expect(script).toBeDefined();
    });

    it('should minify script when requested', () => {
      const options: PACGenerationOptions = {
        minify: true
      };

      const normalScript = generator.generate(testRules);
      const minifiedScript = generator.generate(testRules, options);
      
      expect(minifiedScript.length).toBeLessThan(normalScript.length);
      expect(minifiedScript).not.toContain('  '); // No double spaces
    });
  });

  describe('validation', () => {
    it('should handle rules with invalid profileId gracefully', () => {
      const rule: Rule = {
        id: 'test',
        name: 'Invalid Profile',
        type: RuleType.DOMAIN,
        pattern: 'example.com',
        profileId: 'non-existent',
        priority: RulePriority.MEDIUM,
        enabled: true,
        createdAt: new Date(),
        updatedAt: new Date()
      };

      const script = generator.generate([rule]);
      // Should default to DIRECT when profile not found
      expect(script).toContain('DIRECT');
    });

    it('should validate generated PAC script syntax', () => {
      const script = generator.generate(testRules);
      
      // Check for basic PAC script structure
      expect(script).toMatch(/function FindProxyForURL\(url, host\)/);
      expect(script).toMatch(/return "[^"]+"/);
      
      // Check for balanced braces
      const openBraces = (script.match(/{/g) || []).length;
      const closeBraces = (script.match(/}/g) || []).length;
      expect(openBraces).toBe(closeBraces);
    });
  });

  describe('complex scenarios', () => {
    it('should handle mixed rule types', () => {
      const mixedRules: Rule[] = [
        {
          id: 'domain-rule',
          name: 'Domain Rule',
          type: RuleType.DOMAIN,
          pattern: 'example.com',
          profileId: 'profile-1',
          priority: RulePriority.HIGH,
          enabled: true,
          createdAt: new Date(),
          updatedAt: new Date()
        },
        {
          id: 'wildcard-rule',
          name: 'Wildcard Rule',
          type: RuleType.WILDCARD,
          pattern: '*.test.com',
          profileId: 'profile-2',
          priority: RulePriority.MEDIUM,
          enabled: true,
          createdAt: new Date(),
          updatedAt: new Date()
        },
        {
          id: 'regex-rule',
          name: 'Regex Rule',
          type: RuleType.REGEX,
          pattern: '^https?://api\\.',
          profileId: 'profile-1',
          priority: RulePriority.LOW,
          enabled: true,
          createdAt: new Date(),
          updatedAt: new Date()
        }
      ];

      const script = generator.generate(mixedRules);
      
      expect(script).toContain('Domain Rule');
      expect(script).toContain('Wildcard Rule');
      expect(script).toContain('Regex Rule');
    });

    it('should handle large number of rules efficiently', () => {
      const manyRules: Rule[] = [];
      for (let i = 0; i < 100; i++) {
        manyRules.push({
          id: `rule-${i}`,
          name: `Rule ${i}`,
          type: RuleType.DOMAIN,
          pattern: `site${i}.com`,
          profileId: i % 2 === 0 ? 'profile-1' : 'profile-2',
          priority: RulePriority.MEDIUM,
          enabled: true,
          createdAt: new Date(),
          updatedAt: new Date()
        });
      }

      const start = performance.now();
      const script = generator.generate(manyRules);
      const duration = performance.now() - start;
      
      expect(script).toBeDefined();
      expect(duration).toBeLessThan(1000); // Should complete in under 1 second
    });
  });
});
