/**
 * PAC Manager
 * Handles all PAC script related functionality including parsing, validation, generation, and testing.
 */

import { Rule } from '../rules/types';
import { ProxyConfig, ProxyProfile } from '../types/proxy';
import {
  PACConfig,
  PACValidationResult,
  PACTestResult,
  PACTestCase,
  PACGenerationOptions,
  PACRuleMapping,
  PACExecutionContext,
  PACFunctionSignatures,
  PACProxyString,
  PACValidationError
} from './types';

/**
 * PAC Script Manager
 */
export class PACManager {
  private pacConfig: PACConfig;

  constructor(config?: PACConfig) {
    this.pacConfig = config || { enabled: false };
  }

  /**
   * Update the PAC configuration
   */
  updateConfig(config: Partial<PACConfig>): void {
    this.pacConfig = { ...this.pacConfig, ...config };
  }

  /**
   * Get the current PAC configuration
   */
  getConfig(): PACConfig {
    return this.pacConfig;
  }

  /**
   * Parse and validate a PAC script
   */
  validateScript(script: string): PACValidationResult {
    const errors: PACValidationError[] = [];

    if (!script.includes('FindProxyForURL')) {
      errors.push({ message: 'PAC script must contain a FindProxyForURL function.', type: 'logic' });
    }

    // Placeholder for more advanced validation (AST parsing, etc.)

    return {
      isValid: errors.length === 0,
      errors,
    };
  }

  /**
   * Generate a PAC script from a set of rules
   */
  generateScript(rules: Rule[], options?: PACGenerationOptions): string {
    const defaultProxy = options?.defaultProxy || 'DIRECT';
    let script = `// Generated by X-Proxy at ${new Date().toISOString()}\n`;

    if (options?.headerComment) {
      script += `// ${options.headerComment}\n`;
    }

    script += `\nfunction FindProxyForURL(url, host) {\n`;

    if (options?.includeDebug) {
      script += `  alert(\"Testing URL: \" + url);\n`;
    }

    for (const rule of rules) {
      const condition = this.convertRuleToPACCondition(rule);
      if (condition) {
        script += `  if (${condition}) {\n`;
        script += `    return \"${this.getProxyString(rule.profileId)}\"; // Rule: ${rule.name}\n`;
        script += `  }\n`;
      }
    }

    script += `\n  return \"${defaultProxy}\";\n`;
    script += `}\n`;

    return script;
  }

  /**
   * Test a PAC script with a given URL
   */
  async testScript(script: string, testCase: PACTestCase, context?: PACExecutionContext): Promise<PACTestResult> {
    // This is a simplified test runner. A real implementation would need a sandboxed environment.
    const startTime = Date.now();
    try {
      // This is a placeholder for a secure PAC evaluation environment
      // **WARNING: Do not use eval() in a real application due to security risks**
      const findProxyForURL = new Function('url', 'host', script + '; return FindProxyForURL(url, host);');
      const result = findProxyForURL(testCase.url, testCase.host);

      return {
        testCase,
        actualResult: result,
        passed: result === testCase.expectedResult,
        executionTime: Date.now() - startTime,
      };
    } catch (error: any) {
      return {
        testCase,
        actualResult: '',
        passed: false,
        error: error.message,
        executionTime: Date.now() - startTime,
      };
    }
  }

  /**
   * Fetch an external PAC script
   */
  async fetchExternalScript(url: string): Promise<string> {
    try {
      const response = await fetch(url);
      if (!response.ok) {
        throw new Error(`Failed to fetch PAC script: ${response.statusText}`);
      }
      return await response.text();
    } catch (error: any) {
      console.error('Error fetching external PAC script:', error);
      throw error;
    }
  }

  private convertRuleToPACCondition(rule: Rule): string | null {
    switch (rule.type) {
      case 'domain':
        return `dnsDomainIs(host, \"${rule.pattern}\")`;
      case 'wildcard':
        return `shExpMatch(host, \"${rule.pattern}\")`;
      case 'regex':
        return `/${rule.pattern}/.test(host)`;
      default:
        return null;
    }
  }

  private getProxyString(profileId: string): PACProxyString {
    // In a real app, you would look up the profile and get its proxy config
    // This is a placeholder
    return `PROXY ${profileId}:8080`;
  }
}

