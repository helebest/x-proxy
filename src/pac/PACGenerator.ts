/**
 * PAC Script Generator
 * Generates optimized PAC scripts from rules and proxy configurations
 */

import { Rule, RuleType, RulePriority } from '../rules/types';
import { ProxyProfile, ProxyType } from '../types/proxy';
import {
  PACGenerationOptions,
  PACRuleMapping,
  PACOptimizationResult,
  PACProxyString
} from './types';

/**
 * PAC Script Generator
 */
export class PACGenerator {
  private profiles: Map<string, ProxyProfile>;
  
  constructor(profiles?: ProxyProfile[]) {
    this.profiles = new Map();
    if (profiles) {
      profiles.forEach(profile => {
        this.profiles.set(profile.id, profile);
      });
    }
  }

  /**
   * Update proxy profiles
   */
  updateProfiles(profiles: ProxyProfile[]): void {
    this.profiles.clear();
    profiles.forEach(profile => {
      this.profiles.set(profile.id, profile);
    });
  }

  /**
   * Generate a PAC script from rules
   */
  generate(rules: Rule[], options?: PACGenerationOptions): string {
    // Sort rules by priority
    const sortedRules = this.sortRulesByPriority(rules);
    
    // Convert rules to PAC mappings
    const mappings = this.convertRulesToMappings(sortedRules);
    
    // Generate the PAC script
    let script = this.generateHeader(options);
    script += this.generateHelperFunctions(options);
    script += this.generateMainFunction(mappings, options);
    
    // Optimize if requested
    if (options?.optimizationLevel && options.optimizationLevel > 0) {
      const optimized = this.optimizeScript(script, options.optimizationLevel);
      script = optimized.optimized;
    }
    
    // Minify if requested
    if (options?.minify) {
      script = this.minifyScript(script);
    }
    
    return script;
  }

  /**
   * Generate script header
   */
  private generateHeader(options?: PACGenerationOptions): string {
    let header = '';
    
    if (!options?.minify) {
      header += '/**\n';
      header += ' * PAC Script generated by X-Proxy\n';
      header += ` * Generated: ${new Date().toISOString()}\n`;
      
      if (options?.headerComment) {
        header += ` * ${options.headerComment}\n`;
      }
      
      header += ' */\n\n';
    }
    
    return header;
  }

  /**
   * Generate helper functions
   */
  private generateHelperFunctions(options?: PACGenerationOptions): string {
    let helpers = '';
    
    if (!options?.minify && options?.includeComments) {
      helpers += '// Helper functions\n';
    }
    
    // Add commonly used helper functions
    helpers += `
function isLocalNetwork(host) {
  return isPlainHostName(host) ||
    dnsDomainIs(host, ".local") ||
    isInNet(dnsResolve(host), "10.0.0.0", "255.0.0.0") ||
    isInNet(dnsResolve(host), "172.16.0.0", "255.240.0.0") ||
    isInNet(dnsResolve(host), "192.168.0.0", "255.255.0.0") ||
    isInNet(dnsResolve(host), "127.0.0.0", "255.255.255.0");
}

function isInDomainList(host, domains) {
  for (var i = 0; i < domains.length; i++) {
    if (dnsDomainIs(host, domains[i])) {
      return true;
    }
  }
  return false;
}

function matchesPattern(str, pattern) {
  return shExpMatch(str, pattern);
}
`;

    if (options?.includeDebug) {
      helpers += `
var debugMode = true;
function debug(msg) {
  if (debugMode && typeof alert !== 'undefined') {
    alert("PAC Debug: " + msg);
  }
}
`;
    }
    
    return helpers + '\n';
  }

  /**
   * Generate main FindProxyForURL function
   */
  private generateMainFunction(
    mappings: PACRuleMapping[],
    options?: PACGenerationOptions
  ): string {
    const defaultProxy = options?.defaultProxy || 'DIRECT';
    let func = 'function FindProxyForURL(url, host) {\n';
    
    if (options?.includeDebug) {
      func += '  debug("URL: " + url + ", Host: " + host);\n';
    }
    
    // Add local network bypass
    func += '  // Bypass proxy for local addresses\n';
    func += '  if (isLocalNetwork(host)) {\n';
    func += '    return "DIRECT";\n';
    func += '  }\n\n';
    
    // Group mappings by proxy result for optimization
    const groupedMappings = this.groupMappingsByProxy(mappings);
    
    // Generate conditions for each group
    for (const [proxyResult, rules] of groupedMappings.entries()) {
      if (rules.length === 1) {
        func += `  // Rule: ${rules[0].rule.name}\n`;
        func += `  if (${rules[0].condition}) {\n`;
        func += `    return "${proxyResult}";\n`;
        func += '  }\n\n';
      } else {
        func += `  // Rules: ${rules.map(r => r.rule.name).join(', ')}\n`;
        func += '  if (\n';
        func += rules.map(r => `    ${r.condition}`).join(' ||\n');
        func += '\n  ) {\n';
        func += `    return "${proxyResult}";\n`;
        func += '  }\n\n';
      }
    }
    
    // Default proxy
    func += '  // Default proxy\n';
    func += `  return "${defaultProxy}";\n`;
    func += '}\n';
    
    return func;
  }

  /**
   * Sort rules by priority (higher priority first)
   */
  private sortRulesByPriority(rules: Rule[]): Rule[] {
    return [...rules].sort((a, b) => {
      // Sort by priority (descending)
      if (a.priority !== b.priority) {
        return b.priority - a.priority;
      }
      // Then by creation date (older first)
      return a.createdAt.getTime() - b.createdAt.getTime();
    });
  }

  /**
   * Convert rules to PAC mappings
   */
  private convertRulesToMappings(rules: Rule[]): PACRuleMapping[] {
    const mappings: PACRuleMapping[] = [];
    
    for (const rule of rules) {
      if (!rule.enabled) continue;
      
      const condition = this.generateCondition(rule);
      const proxyResult = this.getProxyString(rule.profileId);
      
      if (condition) {
        mappings.push({
          rule,
          condition,
          proxyResult,
          priority: rule.priority
        });
      }
    }
    
    return mappings;
  }

  /**
   * Generate PAC condition from rule
   */
  private generateCondition(rule: Rule): string | null {
    switch (rule.type) {
      case RuleType.DOMAIN:
        return this.generateDomainCondition(rule.pattern);
      
      case RuleType.WILDCARD:
        return this.generateWildcardCondition(rule.pattern);
      
      case RuleType.REGEX:
        return this.generateRegexCondition(rule.pattern);
      
      case RuleType.IP_RANGE:
        return this.generateIPRangeCondition(rule.pattern);
      
      case RuleType.SCHEME:
        return this.generateSchemeCondition(rule.pattern);
      
      default:
        return null;
    }
  }

  /**
   * Generate domain condition
   */
  private generateDomainCondition(pattern: string): string {
    // Handle subdomain matching
    if (pattern.startsWith('.')) {
      return `dnsDomainIs(host, "${pattern}")`;
    }
    // Exact domain match
    return `(host === "${pattern}" || dnsDomainIs(host, ".${pattern}"))`;
  }

  /**
   * Generate wildcard condition
   */
  private generateWildcardCondition(pattern: string): string {
    // Convert wildcard to shell expression
    const shellPattern = pattern
      .replace(/\./g, '\\.')
      .replace(/\*/g, '*')
      .replace(/\?/g, '?');
    
    return `shExpMatch(host, "${shellPattern}")`;
  }

  /**
   * Generate regex condition
   */
  private generateRegexCondition(pattern: string): string {
    // Use a helper function for regex matching
    return `(new RegExp("${pattern.replace(/"/g, '\\"')}")).test(host)`;
  }

  /**
   * Generate IP range condition
   */
  private generateIPRangeCondition(pattern: string): string {
    // Parse IP range pattern (e.g., "192.168.0.0/16")
    const [ip, maskBits] = pattern.split('/');
    const mask = this.calculateSubnetMask(parseInt(maskBits, 10));
    
    return `isInNet(dnsResolve(host), "${ip}", "${mask}")`;
  }

  /**
   * Generate scheme condition
   */
  private generateSchemeCondition(pattern: string): string {
    const schemes = pattern.toLowerCase().split(',').map(s => s.trim());
    const conditions = schemes.map(scheme => `url.indexOf("${scheme}://") === 0`);
    
    if (conditions.length === 1) {
      return conditions[0];
    }
    return `(${conditions.join(' || ')})`;
  }

  /**
   * Get proxy string for a profile ID
   */
  private getProxyString(profileId: string): PACProxyString {
    const profile = this.profiles.get(profileId);
    
    if (!profile) {
      return 'DIRECT';
    }
    
    const { type, host, port } = profile.config;
    
    switch (type) {
      case ProxyType.HTTP:
        return `PROXY ${host}:${port}`;
      
      case ProxyType.HTTPS:
        return `HTTPS ${host}:${port}`;
      
      case ProxyType.SOCKS4:
        return `SOCKS4 ${host}:${port}`;
      
      case ProxyType.SOCKS5:
        return `SOCKS5 ${host}:${port}`;
      
      case ProxyType.DIRECT:
        return 'DIRECT';
      
      case ProxyType.SYSTEM:
        return 'DIRECT'; // System proxy is handled by OS
      
      default:
        return `PROXY ${host}:${port}`;
    }
  }

  /**
   * Group mappings by proxy result for optimization
   */
  private groupMappingsByProxy(mappings: PACRuleMapping[]): Map<string, PACRuleMapping[]> {
    const grouped = new Map<string, PACRuleMapping[]>();
    
    for (const mapping of mappings) {
      const existing = grouped.get(mapping.proxyResult) || [];
      existing.push(mapping);
      grouped.set(mapping.proxyResult, existing);
    }
    
    return grouped;
  }

  /**
   * Calculate subnet mask from CIDR bits
   */
  private calculateSubnetMask(bits: number): string {
    const mask = [];
    for (let i = 0; i < 4; i++) {
      const n = Math.min(8, Math.max(0, bits - i * 8));
      mask.push(256 - Math.pow(2, 8 - n));
    }
    return mask.join('.');
  }

  /**
   * Optimize PAC script
   */
  optimizeScript(script: string, level: number): PACOptimizationResult {
    const original = script;
    let optimized = script;
    const suggestions: string[] = [];
    
    if (level >= 1) {
      // Remove unnecessary whitespace
      optimized = optimized.replace(/\s+/g, ' ');
      optimized = optimized.replace(/\s*([{}();,])\s*/g, '$1');
      suggestions.push('Removed unnecessary whitespace');
    }
    
    if (level >= 2) {
      // Combine similar conditions
      optimized = this.combineSimilarConditions(optimized);
      suggestions.push('Combined similar conditions');
      
      // Cache DNS lookups
      optimized = this.cacheDNSLookups(optimized);
      suggestions.push('Added DNS lookup caching');
    }
    
    if (level >= 3) {
      // Reorder conditions by likelihood
      optimized = this.reorderConditions(optimized);
      suggestions.push('Reordered conditions for better performance');
      
      // Convert to lookup tables where possible
      optimized = this.convertToLookupTables(optimized);
      suggestions.push('Converted lists to lookup tables');
    }
    
    const sizeReduction = ((original.length - optimized.length) / original.length) * 100;
    
    return {
      original,
      optimized,
      sizeReduction,
      suggestions
    };
  }

  /**
   * Minify PAC script
   */
  private minifyScript(script: string): string {
    // Remove comments
    let minified = script.replace(/\/\*[\s\S]*?\*\//g, '');
    minified = minified.replace(/\/\/.*$/gm, '');
    
    // Remove unnecessary whitespace
    minified = minified.replace(/\s+/g, ' ');
    minified = minified.replace(/\s*([{}();,=<>!&|])\s*/g, '$1');
    
    // Remove leading/trailing whitespace
    minified = minified.trim();
    
    return minified;
  }

  /**
   * Combine similar conditions (optimization)
   */
  private combineSimilarConditions(script: string): string {
    // This is a simplified version - a real implementation would use AST parsing
    return script;
  }

  /**
   * Cache DNS lookups (optimization)
   */
  private cacheDNSLookups(script: string): string {
    // Add DNS caching at the beginning of FindProxyForURL
    const cacheCode = `
  var dnsCache = {};
  var originalDnsResolve = dnsResolve;
  dnsResolve = function(host) {
    if (!(host in dnsCache)) {
      dnsCache[host] = originalDnsResolve(host);
    }
    return dnsCache[host];
  };
`;
    
    return script.replace(
      'function FindProxyForURL(url, host) {',
      'function FindProxyForURL(url, host) {' + cacheCode
    );
  }

  /**
   * Reorder conditions by likelihood (optimization)
   */
  private reorderConditions(script: string): string {
    // This would require usage statistics to properly implement
    return script;
  }

  /**
   * Convert to lookup tables (optimization)
   */
  private convertToLookupTables(script: string): string {
    // Convert domain lists to hash tables for O(1) lookup
    return script;
  }
}
